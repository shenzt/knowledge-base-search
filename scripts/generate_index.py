#!/usr/bin/env python3
"""ç”ŸæˆçŸ¥è¯†åº“ INDEX.md â€” CI ç”¨è„šæœ¬ã€‚

æ¢ç´¢ KB ä»“åº“ç›®å½•ç»“æ„ï¼Œè°ƒç”¨ LLM ç”Ÿæˆ INDEX.md å¯¼èˆªæŒ‡å—ã€‚
æœ¬åœ°äº¤äº’ä½¿ç”¨ /generate-index skillï¼ŒCI ä½¿ç”¨æœ¬è„šæœ¬ã€‚

ç”¨æ³•:
  python scripts/generate_index.py kb/kb-redis-docs

ç¯å¢ƒå˜é‡:
  INDEX_GEN_PROVIDER: openai (é»˜è®¤)
  INDEX_GEN_MODEL: deepseek-chat (é»˜è®¤)
  INDEX_GEN_BASE_URL: https://api.deepseek.com (é»˜è®¤)
  INDEX_GEN_API_KEY: API key (å¿…éœ€)
"""

import argparse
import logging
import os
import sys
from pathlib import Path

from dotenv import load_dotenv
load_dotenv()

logging.basicConfig(level=logging.INFO, format="%(message)s")
log = logging.getLogger(__name__)


def explore_repo(kb_path: str) -> str:
    """æ¢ç´¢ KB ä»“åº“ï¼Œè¿”å›ç»“æ„åŒ–æè¿°ã€‚"""
    root = Path(kb_path)
    docs_root = None

    # æ‰¾åˆ° docs æ ¹ç›®å½•
    for candidate in [root / "docs", root]:
        if candidate.is_dir() and list(candidate.glob("*/_index.md")):
            docs_root = candidate
            break

    if docs_root is None:
        # å°è¯•æ›´æ·±ä¸€å±‚
        for d in root.rglob("_index.md"):
            docs_root = d.parent.parent
            break

    if docs_root is None:
        raise ValueError(f"æ‰¾ä¸åˆ°æ–‡æ¡£æ ¹ç›®å½•: {kb_path}")

    lines = []
    lines.append(f"# KB Repo: {kb_path}")
    lines.append(f"# Docs root: {docs_root}")
    lines.append("")

    # ç»Ÿè®¡æ€»æ–‡ä»¶æ•°
    all_md = list(docs_root.rglob("*.md"))
    lines.append(f"Total .md files: {len(all_md)}")
    lines.append("")

    # é¡¶å±‚ç›®å½•ç»Ÿè®¡
    lines.append("## Top-level directories:")
    top_dirs = sorted([d for d in docs_root.iterdir() if d.is_dir()])
    for d in top_dirs:
        count = len(list(d.rglob("*.md")))
        lines.append(f"  {d.name}/ ({count} files)")

        # äºŒçº§ç›®å½•
        sub_dirs = sorted([sd for sd in d.iterdir() if sd.is_dir()])
        for sd in sub_dirs:
            sub_count = len(list(sd.rglob("*.md")))
            if sub_count > 0:
                lines.append(f"    {sd.name}/ ({sub_count} files)")
    lines.append("")

    # æ£€æµ‹ç‰ˆæœ¬ç›®å½•
    import re
    version_pattern = re.compile(r'^\d+\.\d+')
    lines.append("## Version directories:")
    for d in docs_root.rglob("*"):
        if d.is_dir() and version_pattern.match(d.name):
            parent_rel = d.parent.relative_to(docs_root)
            count = len(list(d.rglob("*.md")))
            lines.append(f"  {parent_rel}/{d.name}/ ({count} files)")
    lines.append("")

    # è¯»å–å…³é”® _index.md æ–‡ä»¶
    lines.append("## Key _index.md contents:")
    index_files = sorted(docs_root.glob("*/_index.md"))
    # ä¹Ÿè¯»äºŒçº§
    index_files += sorted(docs_root.glob("*/*/_index.md"))

    for idx_file in index_files[:20]:  # é™åˆ¶æ•°é‡
        rel = idx_file.relative_to(docs_root)
        content = idx_file.read_text(errors="replace")
        # åªå– frontmatter + å‰ 500 å­—ç¬¦
        if len(content) > 800:
            content = content[:800] + "\n... (truncated)"
        lines.append(f"\n### {rel}")
        lines.append(content)

    return "\n".join(lines)


SYSTEM_PROMPT = """You are a technical documentation analyst. Generate an INDEX.md file for a knowledge base repository.

The INDEX.md serves as a navigation guide for an AI search agent. It should be:
- Concise (3-5KB)
- Actionable: "if question is about X, search in Y/"
- Accurate: based only on the repo structure provided
- Written for an AI agent, not a human reader"""

USER_PROMPT_TEMPLATE = """Based on this repository structure analysis, generate an INDEX.md file.

{repo_analysis}

Generate the INDEX.md with these sections:
1. **Overview**: source, doc count, language, generation date
2. **Directory Map**: table with path, topic, doc count, description (for both top-level areas)
3. **Version Strategy**: which areas have versions, which is latest, search rules (default to non-versioned)
4. **Topic Routing**: table mapping question types to search paths
5. **Excluded Paths**: version directories to skip during indexing
6. **Answer Rules**: citation format, version handling, Hugo shortcode notes

Use markdown tables. Be precise with directory names and file counts.
Start with: # <KB Name> â€” Search Index Guide
Include a note that this was generated by /generate-index.

Output ONLY the markdown content, no code fences."""


def generate_index(kb_path: str) -> str:
    """æ¢ç´¢ä»“åº“å¹¶è°ƒç”¨ LLM ç”Ÿæˆ INDEX.mdã€‚"""
    log.info(f"ğŸ“‚ æ¢ç´¢ä»“åº“: {kb_path}")
    repo_analysis = explore_repo(kb_path)
    log.info(f"ğŸ“Š åˆ†æå®Œæˆ: {len(repo_analysis)} å­—ç¬¦")

    # LLM è°ƒç”¨
    provider = os.environ.get("INDEX_GEN_PROVIDER", "openai")
    model = os.environ.get("INDEX_GEN_MODEL", "deepseek-chat")
    base_url = os.environ.get("INDEX_GEN_BASE_URL", "https://api.deepseek.com")
    api_key = os.environ.get("INDEX_GEN_API_KEY", "")

    if not api_key:
        raise ValueError("INDEX_GEN_API_KEY ç¯å¢ƒå˜é‡æœªè®¾ç½®")

    from openai import OpenAI
    client = OpenAI(api_key=api_key, base_url=base_url)

    log.info(f"ğŸ¤– è°ƒç”¨ LLM: {model} @ {base_url}")
    prompt = USER_PROMPT_TEMPLATE.format(repo_analysis=repo_analysis)

    resp = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": prompt},
        ],
        max_tokens=4096,
        temperature=0,
    )

    return resp.choices[0].message.content


def main() -> None:
    parser = argparse.ArgumentParser(description="ç”ŸæˆçŸ¥è¯†åº“ INDEX.md")
    parser.add_argument("kb_path", help="KB ä»“åº“è·¯å¾„ (e.g., kb/kb-redis-docs)")
    parser.add_argument("--dry-run", action="store_true", help="åªè¾“å‡ºä¸å†™æ–‡ä»¶")
    args = parser.parse_args()

    content = generate_index(args.kb_path)

    if args.dry_run:
        print(content)
    else:
        output = os.path.join(args.kb_path, "INDEX.md")
        with open(output, "w") as f:
            f.write(content)
        log.info(f"âœ… å†™å…¥ {output} ({len(content)} å­—ç¬¦)")


if __name__ == "__main__":
    main()
