#!/usr/bin/env python3
"""扩展测试用例 — 基于全量 K8s + Redis 官方文档。

将此文件的 EXPANDED_QDRANT_CASES 和 EXPANDED_NOTFOUND_CASES 合并到
test_agentic_rag_sdk.py 的 TEST_CASES 中。
"""

# ── 新增 Qdrant 用例：Redis 官方文档 ──

REDIS_QDRANT_CASES = [
    # Redis Sentinel (official English doc)
    {"id": "qdrant-redis-sentinel-001",
     "query": "How does Redis Sentinel automatic failover work?",
     "category": "redis-sentinel", "type": "concept", "source": "qdrant",
     "expected_doc": "sentinel.md",
     "note": "Official Sentinel doc has full failover explanation"},
    {"id": "qdrant-redis-sentinel-002",
     "query": "Redis Sentinel 的 quorum 是什么意思？怎么配置？",
     "category": "redis-sentinel", "type": "howto", "source": "qdrant",
     "expected_doc": "sentinel.md",
     "note": "Cross-lang: Chinese question → English doc"},

    # Redis Replication
    {"id": "qdrant-redis-repl-001",
     "query": "Redis master-replica replication 是异步的还是同步的？",
     "category": "redis-replication", "type": "concept", "source": "qdrant",
     "expected_doc": "replication.md",
     "note": "Replication doc explains async replication + WAIT"},
    {"id": "qdrant-redis-repl-002",
     "query": "Redis replica 断开连接后重连，是全量同步还是部分同步？",
     "category": "redis-replication", "type": "scenario", "source": "qdrant",
     "expected_doc": "replication.md",
     "note": "Partial resync vs full resync"},

    # Redis Persistence
    {"id": "qdrant-redis-persist-001",
     "query": "RDB 和 AOF 有什么区别？该用哪个？",
     "category": "redis-persistence", "type": "concept", "source": "qdrant",
     "expected_doc": "persistence.md",
     "note": "Core Redis persistence comparison"},
    {"id": "qdrant-redis-persist-002",
     "query": "Redis AOF rewrite 是怎么工作的？会阻塞主线程吗？",
     "category": "redis-persistence", "type": "scenario", "source": "qdrant",
     "expected_doc": "persistence.md",
     "note": "AOF rewrite mechanism"},

    # Redis Cluster / Scaling
    {"id": "qdrant-redis-cluster-001",
     "query": "Redis Cluster 的 hash slot 是怎么分配的？",
     "category": "redis-scaling", "type": "concept", "source": "qdrant",
     "expected_doc": "scaling.md",
     "note": "Cluster hash slot distribution"},

    # Redis Data Types
    {"id": "qdrant-redis-strings-001",
     "query": "Redis Strings 除了缓存还能做什么？支持哪些操作？",
     "category": "redis-strings", "type": "concept", "source": "qdrant",
     "expected_doc": "strings.md",
     "note": "String operations: counters, bitwise, etc."},
    {"id": "qdrant-redis-sorted-set-001",
     "query": "How to implement a leaderboard with Redis Sorted Sets?",
     "category": "redis-sorted-sets", "type": "howto", "source": "qdrant",
     "expected_doc": "sorted-sets.md",
     "note": "Classic sorted set use case"},
    {"id": "qdrant-redis-streams-001",
     "query": "Redis Streams 和 Pub/Sub 有什么区别？什么时候用 Streams？",
     "category": "redis-streams", "type": "concept", "source": "qdrant",
     "expected_doc": "streams/_index.md",
     "note": "Streams vs Pub/Sub comparison"},
    {"id": "qdrant-redis-bloom-001",
     "query": "What is a Bloom filter in Redis and when should I use it?",
     "category": "redis-bloom", "type": "concept", "source": "qdrant",
     "expected_doc": "bloom-filter.md",
     "note": "Probabilistic data structure"},

    # Redis Operations
    {"id": "qdrant-redis-latency-001",
     "query": "Redis 延迟突然变高怎么排查？有哪些常见原因？",
     "category": "redis-latency", "type": "scenario", "source": "qdrant",
     "expected_doc": "latency.md",
     "note": "Latency troubleshooting guide"},
    {"id": "qdrant-redis-memory-001",
     "query": "Redis 内存占用太高怎么优化？",
     "category": "redis-memory", "type": "scenario", "source": "qdrant",
     "expected_doc": "memory-optimization.md",
     "note": "Memory optimization techniques"},
    {"id": "qdrant-redis-acl-001",
     "query": "How to set up Redis ACL to restrict user permissions?",
     "category": "redis-acl", "type": "howto", "source": "qdrant",
     "expected_doc": "acl.md",
     "note": "Redis 6+ ACL system"},
    {"id": "qdrant-redis-pipelining-001",
     "query": "Redis pipelining 的原理是什么？和普通请求有什么区别？",
     "category": "redis-pipelining", "type": "concept", "source": "qdrant",
     "expected_doc": "pipelining.md",
     "note": "Pipelining in official docs"},
    {"id": "qdrant-redis-transactions-001",
     "query": "Redis MULTI/EXEC 事务和 Lua 脚本哪个更好？",
     "category": "redis-transactions", "type": "concept", "source": "qdrant",
     "expected_doc": "transactions.md",
     "note": "Transactions vs Lua scripting"},
    {"id": "qdrant-redis-debug-001",
     "query": "线上 Redis 出问题了怎么 debug？有哪些诊断命令？",
     "category": "redis-debugging", "type": "scenario", "source": "qdrant",
     "expected_doc": "debugging.md",
     "note": "Redis debugging guide"},
    {"id": "qdrant-redis-benchmark-001",
     "query": "How to benchmark Redis performance? What tool should I use?",
     "category": "redis-benchmark", "type": "howto", "source": "qdrant",
     "expected_doc": "benchmarks/index.md",
     "note": "Redis benchmark tool and methodology"},

    # Redis SO-style scenarios
    {"id": "qdrant-redis-so-001",
     "query": "我的 Redis 主从同步一直断，日志里刷 LOADING Redis is loading the dataset in memory",
     "category": "redis-replication", "type": "scenario", "source": "qdrant",
     "expected_doc": "replication.md",
     "note": "SO-style: full resync loop problem"},
    {"id": "qdrant-redis-so-002",
     "query": "Redis used_memory 比 maxmemory 大很多，但 keys 不多，内存去哪了？",
     "category": "redis-memory", "type": "scenario", "source": "qdrant",
     "expected_doc": "memory-optimization.md",
     "note": "SO-style: memory fragmentation"},
]

# ── 新增 Qdrant 用例：K8s 官方文档 ──

K8S_QDRANT_CASES = [
    # K8s core concepts
    {"id": "qdrant-k8s-pod-001",
     "query": "What is a Pod in Kubernetes?",
     "category": "k8s-pod", "type": "concept", "source": "qdrant",
     "expected_doc": "pods/_index.md",
     "note": "Core Pod concept"},
    {"id": "qdrant-k8s-service-001",
     "query": "Kubernetes Service 有哪些类型？ClusterIP 和 NodePort 的区别？",
     "category": "k8s-service", "type": "concept", "source": "qdrant",
     "expected_doc": "service.md",
     "note": "Service types comparison"},
    {"id": "qdrant-k8s-deploy-001",
     "query": "Deployment 滚动更新卡住了，新旧 Pod 并存，怎么回滚？",
     "category": "k8s-deployment", "type": "scenario", "source": "qdrant",
     "expected_doc": "deployment.md",
     "note": "Deployment rollback"},
    {"id": "qdrant-k8s-configmap-001",
     "query": "How to use ConfigMap to inject configuration into a Pod?",
     "category": "k8s-configmap", "type": "howto", "source": "qdrant",
     "expected_doc": "configmap.md",
     "note": "ConfigMap usage patterns"},
    {"id": "qdrant-k8s-secret-001",
     "query": "Kubernetes Secret 和 ConfigMap 有什么区别？Secret 安全吗？",
     "category": "k8s-secret", "type": "concept", "source": "qdrant",
     "expected_doc": "secret.md",
     "note": "Secret vs ConfigMap"},
    {"id": "qdrant-k8s-probe-001",
     "query": "liveness probe 和 readiness probe 有什么区别？什么时候用哪个？",
     "category": "k8s-probes", "type": "concept", "source": "qdrant",
     "expected_doc": "liveness-readiness-startup-probes.md",
     "note": "Probe types comparison"},
    {"id": "qdrant-k8s-ingress-001",
     "query": "How does Kubernetes Ingress route traffic to different services?",
     "category": "k8s-ingress", "type": "concept", "source": "qdrant",
     "expected_doc": "ingress.md",
     "note": "Ingress routing rules"},
    {"id": "qdrant-k8s-volume-001",
     "query": "Kubernetes 里怎么给 Pod 挂载持久化存储？PV 和 PVC 的关系？",
     "category": "k8s-volumes", "type": "concept", "source": "qdrant",
     "expected_doc": "volumes.md",
     "note": "Volumes, PV, PVC"},
    {"id": "qdrant-k8s-init-001",
     "query": "What are Init Containers and when should I use them?",
     "category": "k8s-init", "type": "concept", "source": "qdrant",
     "expected_doc": "init-containers.md",
     "note": "Init container use cases"},
    {"id": "qdrant-k8s-lifecycle-001",
     "query": "Pod 的生命周期有哪些阶段？Pending 和 Running 的区别？",
     "category": "k8s-lifecycle", "type": "concept", "source": "qdrant",
     "expected_doc": "pod-lifecycle.md",
     "note": "Pod lifecycle phases"},
    {"id": "qdrant-k8s-namespace-001",
     "query": "Kubernetes Namespace 是什么？什么时候需要用多个 Namespace？",
     "category": "k8s-namespace", "type": "concept", "source": "qdrant",
     "expected_doc": "namespaces.md",
     "note": "Namespace isolation"},
    {"id": "qdrant-k8s-label-001",
     "query": "How do Labels and Selectors work in Kubernetes?",
     "category": "k8s-labels", "type": "concept", "source": "qdrant",
     "expected_doc": "labels.md",
     "note": "Labels and selectors"},
    {"id": "qdrant-k8s-resource-001",
     "query": "怎么给 Pod 设置 CPU 和内存的 requests 和 limits？",
     "category": "k8s-resources", "type": "howto", "source": "qdrant",
     "expected_doc": "manage-resources-containers.md",
     "note": "Resource management"},
    {"id": "qdrant-k8s-node-001",
     "query": "Kubernetes Node 的状态有哪些？NotReady 是什么意思？",
     "category": "k8s-nodes", "type": "concept", "source": "qdrant",
     "expected_doc": "nodes.md",
     "note": "Node status conditions"},
    {"id": "qdrant-k8s-gc-001",
     "query": "Kubernetes garbage collection 是怎么清理资源的？",
     "category": "k8s-gc", "type": "concept", "source": "qdrant",
     "expected_doc": "garbage-collection.md",
     "note": "GC mechanisms: owner references, cascading delete"},

    # K8s SO-style scenarios
    {"id": "qdrant-k8s-so-001",
     "query": "Pod 一直 Pending 不调度，describe 显示 Insufficient cpu，怎么办？",
     "category": "k8s-resources", "type": "scenario", "source": "qdrant",
     "expected_doc": "manage-resources-containers.md",
     "note": "SO-style: resource quota issue"},
    {"id": "qdrant-k8s-so-002",
     "query": "Deployment rollout 卡在 Progressing，maxUnavailable 和 maxSurge 怎么调？",
     "category": "k8s-deployment", "type": "scenario", "source": "qdrant",
     "expected_doc": "deployment.md",
     "note": "SO-style: rolling update stuck"},
    {"id": "qdrant-k8s-so-003",
     "query": "What's the difference between a Deployment and a ReplicationController?",
     "category": "k8s-deploy-vs-rc", "type": "concept", "source": "qdrant",
     "expected_doc": "deployment.md,replicationcontroller.md",
     "note": "Comparison question"},
    {"id": "qdrant-k8s-so-004",
     "query": "Container 的 preStop hook 没执行就被 kill 了，怎么保证优雅退出？",
     "category": "k8s-lifecycle-hooks", "type": "scenario", "source": "qdrant",
     "expected_doc": "container-lifecycle-hooks.md",
     "note": "SO-style: graceful shutdown"},
    {"id": "qdrant-k8s-so-005",
     "query": "LimitRange 和 ResourceQuota 有什么区别？怎么限制单个 Pod 的资源？",
     "category": "k8s-policy", "type": "concept", "source": "qdrant",
     "expected_doc": "limit-range.md,resource-quotas.md",
     "note": "Policy comparison"},
]

# ── 新增 notfound 用例 ──

EXPANDED_NOTFOUND_CASES = [
    {"id": "notfound-004",
     "query": "Kafka consumer group rebalance 怎么优化？",
     "category": "not-in-kb", "type": "notfound", "source": "none",
     "expect_no_results": True,
     "note": "KB 没有 Kafka 内容"},
    {"id": "notfound-005",
     "query": "How to set up Prometheus alerting rules?",
     "category": "not-in-kb", "type": "notfound", "source": "none",
     "expect_no_results": True,
     "note": "KB 没有 Prometheus 内容"},
    {"id": "notfound-006",
     "query": "Nginx 反向代理配置 upstream 负载均衡",
     "category": "not-in-kb", "type": "notfound", "source": "none",
     "expect_no_results": True,
     "note": "KB 没有 Nginx 内容"},
    {"id": "notfound-007",
     "query": "MySQL InnoDB 死锁怎么排查和解决？",
     "category": "not-in-kb", "type": "notfound", "source": "none",
     "expect_no_results": True,
     "note": "KB 没有 MySQL 内容"},
    {"id": "notfound-008",
     "query": "Docker Compose 多容器编排怎么配置网络？",
     "category": "not-in-kb", "type": "notfound", "source": "none",
     "expect_no_results": True,
     "note": "KB 没有 Docker Compose 内容"},
]
